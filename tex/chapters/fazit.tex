\chapter{Fazit und Ausblick}

Das direkte Resultat dieser Arbeit ist zunächst, dass \Cref{lem:filtrprinc} und \Cref{lem:fz} korrekt sind. Die hier vorgestellte Verifikation liefert zudem eine Implementierung der Teilformelfiltration und des Teilformelkalküls, die als Basis sowohl für weitere Verifikationen, sowie für weitere Forschung an der prinzipalen Inhabitation genutzt werden kann. Allen voran steht hier der Abschluss der Verifikation, der in \cite{dudenhefner} genutzten Techniken sowie dem Beantworten der dort aufgestellten Vermutung und der Implementierung des dort vorgestellten Inhabitationsalgorithmus.

\section{\coq{} als Beweishelfer}
Grundsätzlich lässt sich feststellen, dass Beweishelfer geeignet sind, komplexe Theorien zu verifizieren. Diese Arbeit zeigt aber auch, dass das Formalisieren von Lemmata und Implementieren von Beweisen deutlich mehr Zeit in Anspruch nimmt, als das reine mathematische Beweisen. Dies liegt mitunter daran, dass selbst offensichtliche Resultate explizit bewiesen werden müssen. Ein Beispiel hierfür ist das Lemma \coqref{P_ok_proof_irl}. Es ist intuitiv klar, dass alle Beweise für das Enthaltensein in $\dom(P_\tau)$ gleichwertig sind. In einer schriftlichen Beweisführung würde kein Unterschied zwischen verschiedenen Beweisen gemacht werden. In \coq{} muss jedoch einerseits diese Beweisirrelevanz explizit gezeigt werden, sowie dieses Resultat an allen Stellen explizit verwendet werden, in denen verschiedene Konstruktionen des Beweises für das Enthaltensein verwendet werden. Ein weiteres Beispiel sind die Generierungslemmata \coqreff{lst:SfC_gen}{SfC_gen_app} und \coqreff{lst:SfC_gen}{SfC_gen_lam}. Diese sagen lediglich aus, dass Abstraktionen mit der Abstraktionsregel und Applikationen mit der Applikationsregel abgeleitet werden. Dies ist über die Struktur von \coqref{SfC} offensichtlich. Für den Beweis in \coq{} muss jedoch ein großer Teil des Beweises als \tlambda-Term explizit angegeben werden. Ein weiteres häufig auftretendes Problem ist, dass Induktionen in \coq{} nicht auf Basisfällen durchgeführt werden kann. Will beispielsweise eine Aussage über \icoq{SfC [] R m []} mit Induktion bewiesen werden, muss diese Aussage über den allgemeinen Fall \icoq{SfC Delta R m pi} getätigt werden. Somit muss in vielen Fällen ein extra Hilfslemma erstellt werden. Siehe hierfür beispielsweise \coqreff{lst:sfc_monotone}{sfc_monotone_aux} und \coqref{Rsub_m_tau_to_Long_aux}.

Der Beweis, der den meisten Aufwand während der Implementierung in Anspruch genommen hat, ist der erste Teil des Lemmas \ref{lem:fz}. In schriftlicher Form können wir beschreiben, dass wir einen Beweisbaum entlang gehen und Schritte der Pfadableitung sich in Schritte der Langableitung übersetzen lassen. Um den Beweis in \coq{} zu Implementieren, wurden mehrere Ansätze versucht. Zunächst wurde versucht, die Aussage direkt per Induktion über die Pfadableitung zu beweisen. Nachdem dies nicht zum Erfolg geführt hat, wurde versucht einen Beweis über die Länge der Pfadableitung zu führen. Ein dritter Ansatz war es, die gesamte Aussage des Beweises in einem Datentyp zu beschreiben und die Inhabitation des Datentyps, zu zeigen. Letztendlich konnte das Lemma mit der Konstruktion \coqref{SfC_subj} bewiesen werden. Es ist auch in der schriftlichen Beweisführung nicht unüblich, dass es mehrere Ansätze bedarf um bestimmte Aussagen zu zeigen. Die Schwierigkeit dieses Lemma zu übertragen, zeigt jedoch, dass, selbst wenn eine Aussage gut verstanden und schriftlich bewiesen wurde, es nicht direkt ersichtlich ist, wie ein solcher Beweis sich in \coq{} übertragen lässt.

Insbesondere im Bezug auf \coq s Standardbibliothek, trat häufiger die Situation auf, dass dort ein Lemma, das für einen Beweis benötigt wird, zwar vorhanden ist, jedoch in einer leicht anderen Form, als die, die benötigt wurde. Hier musste dann entweder die Äquivalenz zwischen der Form der Standardbibliothek und der eigenen Implementierung gezeigt werden oder das entsprechende Resultat von Grund auf selbst bewiesen werden, wie beispielsweise das Konstrukt \texttt{Forall\_T}. Da die Ableitungsbeweise und Konstruktionen in \texttt{Type} formuliert wurden, konnte nicht \icoq{Forall} aus der Standardbibliothek verwendet werden, da \icoq{Forall} in \texttt{Prop} formuliert ist. \icoq{Forall_T} und \icoq{Forall} arbeiten exakt identisch und vergleichbare Aussagen über beide wurden identisch bewiesen; es musste dennoch explizit erneut aufgestellt werden. Eine Verallgemeinerung des Datentyps \icoq{Forall} zu \texttt{Type} wurde dieses Problem lösen. Dies wäre auch ganz im Sinne der Prinzipalität. 

In schriftlichen Beweisen ist es zudem einfacher, bereits bewiesene Resultate in externen Arbeiten zu zitieren. In dem Fall der Enscheidbarkeit des transitiven Abschlusses (Siehe \Cref{sec:ts_dec}) könnte auf die Bibliothek \textsc{math-comp}\footnote{https://github.com/math-comp/math-comp} verwiesen werden, in der dies über eine Tiefensuche bewiesen wurde. Da dieser Beweis eine so andere Implementierung von Graphen nutzt, ist es einfacher gewesen die Entscheidbarkeit selbst zu zeigen, als eine Äquivalenz der beiden Implementierungen.

Grundsätzlich sorgen diese Eigenschaften für deutlich mehr Arbeitsaufwand, als das Beweisen auf Papier, jedoch führen sie zu einer Form, die der Typchecker von \coq{} einfach Verifizieren kann. Insgesamt wurde für die Implementierung 5631 Zeilen Code geschrieben\footnote{Gezählt durch \texttt{cloc}}.

Es ist zu erwarten, dass die genannten Probleme auch für weitergehende Verifikationen im \tlambda-Kalkül gelten, jedoch ist ebenfalls anzunehmen, dass hierdurch eine umfassende Bibliothek an Lemmata entsteht, die das Formulieren und Beweisen von Aussagen im \tlambda-Kalkül kontinuierlich vereinfachen. An dieser Stelle seinen noch einige Ideen zur Verbesserung der Implementierung gegeben. Zum einen wuchs das Wissen um \coq{} kontinuierlich mit Fortschritt der Implementierung, sodass Lemmata, die zu Beginn aufgestellt wurden unstrukturierter und schwieriger nachzuvollziehen sind, als jene, die in am Ende aufgestellt und bewiesen wurden. Hier kann im Bezug auf die Lesbarkeit einiges verbessert werden. Zum anderen wurde wenige eigene Taktiken mittels $L_{\text{tac}}$\footnote{\url{https://coq.inria.fr/refman/proof-engine/ltac.html}} umgesetzt auch hierdurch kann die Lesbarkeit noch erhöht werden. Zuletzt wurde nur wenig Gebrauch von \emph{hint databases} gemacht, die die Taktik \icoq{auto} befüllen. 

\section{Ausblick}

Die prinzipale Inhabitation und die Prinzipalität an sich, sind noch verhältnismäßig wenig erforschte Themen. Eine grundlegende Arbeit ist hier \cite{broda} von 1999, in der ein Algorithmus vorgestellt wird, um prinzipale Inhabitanten eines Typs zu zählen. In neuerer Zeit ist die prinzipale Inhabitation Thema von \cite{dudenhefner}, sowie von \cite{machine}. Letzteres erweitert die in \cite{schubert} aufgestellten \emph{Inhabitationsautomaten}, um Resultate über die prinzipale Inhabitation zu erhalten. In \cite{dudenhefner} wird vorgeschlagen, die prinzipale Inhabitation auch in anderen Typsystemen zu untersuchen. Hier werden allen voran die Intersektionstypen \cite{coppo1980} genannt.

Interessant ist auch die Untersuchung in konkreten Programmiersprachen. Betrachten wir das in der Einleitung erwähnte Beispiel der Identität. Eine Compiler könnte feststellen, dass der Typ $\texttt{int} \to \texttt{int}$ nicht der prinzipale Typ der Identität ist, und dies mit einer Warnung anmerken und einen prinzipalen Typ generieren. Hierdurch kann mehrfacher Code vermieden werden. Tatsächlich bietet \textsc{OCaml} die Option \texttt{-principal}, die die eingebaute Typableitung so gestaltet, dass alle Typen prinzipal sind.\footnote{Siehe \texttt{man 1 ocaml} oder \url{https://linux.die.net/man/1/ocaml}} 

Über den \emph{Curry-Howard-Isomorphismus} kann untersucht werden, welche Bedeutung eine prinzipale Aussage zu einem Beweis hat. Auf den ersten Blick entspricht dies einem Beweis, der nicht mehr beweist, als die Aussage, für die er aufgestellt wurde. Hiermit könnten allgemeinere Resultate zu bestehenden Beweisen gefunden werden. Im Bezug auf die Inhabitation könnte dies zu einer stärkeren Form der \emph{Beweisnormalisierung}\cite{lecturesCH} führen, sodass nicht nur normalisierte Beweise generiert werden, sondern insbesondere \emph{kleinste} normalisierte Beweise.

Die Erweiterung des \emph{Curry-Howard-Isomorphismus} zum \emph{Curry-Howard-Lambek-Isomorphismus}\cite{ccc} erlaubt es, die Prinzipalität in den kartesisch abgeschlossenen Kategorien zu untersuchen. Grundsätzlich sagt diese Erweiterung aus, dass Typen Objekte einer kartesisch abgeschlossenen Kategorie sind, deren Morphismen die vom Zielobjekt inhabitierte \tlambda-Terme mit einer freien Variable des Quellobjektes sind. Eine kartesisch abgeschlossene Kategorie erfordert unter anderem, dass zu jeden Objekten $A$ und $B$ sowohl das Produkt $A\times B$ als auch die Potenz $A^B$ existieren. Letzteres können wir auch als $B \to A$ schreiben und entspricht somit einem Pfeiltypen. Hier kann untersucht werden, ob die Einschränkung auf prinzipale Inhabitanten ebenfalls eine Kategorie ergibt, welche Eigenschaften diese hat, und inwieweit dies dem Verständnis der Prinzipalität dient.

Wir schließen mit einer letzten Betrachtungsweise prinzipaler Typen, indem wir \Cref{def:subtype} und \Cref{lem:subord} betrachten. Die Subtyprelation $\preceq$ zusammen mit $\mathbb{T}_M$, der Menge aller Typen, die von einem gegebenen Term $M$ inhabitiert werden, ergeben den Verband $(\mathbb{T}_M, \preceq)$, dessen Minimum genau der prinzipale Typ von $M$ ist. Diese Beobachtung ist eng verwandt mit dem allgemeineren Konzept der \emph{prinzipalen Algebra}\cite{henk}, in denen der prinzipale Typ final ist.

Wir können also schließen, dass sowohl die Prinzipalität und prinzipale Inhabitation als auch die Verifikation mittels \coq{} eine wichtige Rolle in zukünftiger Forschung spielen werden.